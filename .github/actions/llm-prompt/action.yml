name: 'LLM Prompt Action'
description: 'Calls StackSpot LLM API with OAuth authentication'
author: 'Your Name'

inputs:
  tenant:
    description: 'StackSpot tenant identifier'
    required: true
  client_id:
    description: 'OAuth client ID'
    required: true
  client_secret:
    description: 'OAuth client secret'
    required: true
  conversation_id:
    description: 'Conversation identifier'
    required: true
  agent_id:
    description: 'Agent identifier'
    required: true
  user_prompt:
    description: 'User prompt for the LLM'
    required: true

outputs:
  response:
    description: 'LLM response text'
    value: ${{ steps.llm.outputs.response }}

runs:
  using: 'composite'
  steps:
    - name: Prepare Input Files
      shell: bash
      run: |
        set -euo pipefail
        
        # Create a secure temporary directory
        TEMP_DIR=$(mktemp -d)
        echo "TEMP_DIR=$TEMP_DIR" >> $GITHUB_ENV
        
        # Write inputs directly to files using GitHub's toJSON to handle escaping
        cat > "$TEMP_DIR/tenant.json" << 'EOF'
        ${{ toJSON(inputs.tenant) }}
        EOF
        
        cat > "$TEMP_DIR/client_id.json" << 'EOF'
        ${{ toJSON(inputs.client_id) }}
        EOF
        
        cat > "$TEMP_DIR/client_secret.json" << 'EOF'
        ${{ toJSON(inputs.client_secret) }}
        EOF
        
        cat > "$TEMP_DIR/conversation_id.json" << 'EOF'
        ${{ toJSON(inputs.conversation_id) }}
        EOF
        
        cat > "$TEMP_DIR/agent_id.json" << 'EOF'
        ${{ toJSON(inputs.agent_id) }}
        EOF
        
        cat > "$TEMP_DIR/user_prompt.json" << 'EOF'
        ${{ toJSON(inputs.user_prompt) }}
        EOF
        
        # Parse JSON files to get actual values
        jq -r '.' "$TEMP_DIR/tenant.json" > "$TEMP_DIR/tenant.txt"
        jq -r '.' "$TEMP_DIR/client_id.json" > "$TEMP_DIR/client_id.txt"
        jq -r '.' "$TEMP_DIR/client_secret.json" > "$TEMP_DIR/client_secret.txt"
        jq -r '.' "$TEMP_DIR/conversation_id.json" > "$TEMP_DIR/conversation_id.txt"
        jq -r '.' "$TEMP_DIR/agent_id.json" > "$TEMP_DIR/agent_id.txt"
        jq -r '.' "$TEMP_DIR/user_prompt.json" > "$TEMP_DIR/user_prompt.txt"
        
        # Mask sensitive data
        echo "::add-mask::$(cat "$TEMP_DIR/client_secret.txt")"
        
        # Validate required inputs
        for file in tenant client_id client_secret conversation_id agent_id user_prompt; do
          if [[ ! -s "$TEMP_DIR/${file}.txt" ]]; then
            echo "Error: Input '${file}' is required but empty"
            exit 1
          fi
        done

    - name: Get OAuth Token
      id: oauth
      shell: bash
      run: |
        set -euo pipefail
        
        TENANT=$(cat "$TEMP_DIR/tenant.txt")
        CLIENT_ID=$(cat "$TEMP_DIR/client_id.txt")
        CLIENT_SECRET=$(cat "$TEMP_DIR/client_secret.txt")
        
        echo "Requesting OAuth token..."
        response=$(curl --fail --silent --location \
          --request POST "https://idm.stackspot.com/${TENANT}/oidc/oauth/token" \
          --header 'Content-Type: application/x-www-form-urlencoded' \
          --data-urlencode "client_id=${CLIENT_ID}" \
          --data-urlencode 'grant_type=client_credentials' \
          --data-urlencode "client_secret=${CLIENT_SECRET}")
        
        if ! token=$(echo "$response" | jq -r '.access_token // empty'); then
          echo "Error: Failed to parse access token from response"
          echo "Response: $response"
          exit 1
        fi
        
        if [[ -z "$token" || "$token" == "null" ]]; then
          echo "Error: No access token received"
          echo "Response: $response"
          exit 1
        fi
        
        echo "::add-mask::$token"
        echo "$token" > "$TEMP_DIR/token.txt"
        echo "token=$token" >> $GITHUB_OUTPUT

    - name: Call LLM API and Set Output
      id: llm
      shell: bash
      run: |
        set -euo pipefail
        
        echo "Calling LLM API..."
        
        # Create the JSON payload directly from files to avoid shell escaping
        jq -nc \
          --rawfile conversation_id "$TEMP_DIR/conversation_id.txt" \
          --rawfile agent_id "$TEMP_DIR/agent_id.txt" \
          --rawfile user_prompt "$TEMP_DIR/user_prompt.txt" \
          '{
            "context": {
              "conversation_id": ($conversation_id | rtrimstr("\n")),
              "upload_ids": [],
              "agent_id": ($agent_id | rtrimstr("\n")),
              "agent_built_in": true,
              "os": "github-action",
              "platform": "github-action",
              "platform_version": "1.0",
              "stackspot_ai_version": "2.4.0"
            },
            "user_prompt": ($user_prompt | rtrimstr("\n"))
          }' > "$TEMP_DIR/payload.json"
        
        TOKEN=$(cat "$TEMP_DIR/token.txt")
        
        echo "Making API request..."
        
        # Make the API call using the payload file
        timeout 300 curl --fail --silent --show-error \
          'https://genai-code-buddy-api.stackspot.com/v3/chat' \
          -H "accept: text/event-stream" \
          -H "authorization: Bearer ${TOKEN}" \
          -H "content-type: application/json" \
          --data-binary "@$TEMP_DIR/payload.json" \
          > "$TEMP_DIR/stream_response.txt" || {
            echo "Error: API call failed"
            if [[ -f "$TEMP_DIR/stream_response.txt" ]]; then
              echo "Stream response content:"
              cat "$TEMP_DIR/stream_response.txt"
            fi
            exit 1
          }
        
        echo "Processing stream response..."
        
        # Process the stream response
        final_response=""
        while IFS= read -r line; do
          if [[ "$line" =~ ^data:\ (.+)$ ]]; then
            data_content="${BASH_REMATCH[1]}"
            if [[ -n "$data_content" && "$data_content" != "{}" ]]; then
              answer=$(echo "$data_content" | jq -r 'select(.answer != null) | .answer' 2>/dev/null || echo "")
              if [[ -n "$answer" ]]; then
                final_response="${final_response}${answer}"
              fi
            fi
          fi
        done < "$TEMP_DIR/stream_response.txt"
        
        if [[ -z "$final_response" ]]; then
          echo "Warning: No response content received from LLM"
        fi
        
        echo "Response length: ${#final_response} characters"
        
        # Set output using proper multiline format
        delimiter="LLMRESPONSE_$(date +%s)_$$"
        {
          echo "response<<${delimiter}"
          echo "$final_response"
          echo "${delimiter}"
        } >> $GITHUB_OUTPUT

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        if [[ -n "${TEMP_DIR:-}" && -d "$TEMP_DIR" ]]; then
          rm -rf "$TEMP_DIR"
        fi